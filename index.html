<!doctype html>  
<html lang="en">  
<head>  
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="description" content="WebGL Benchmark Test" />
  <title>blackhole_bm</title> 
  <meta name="keywords" content="blackhole_bm, BlackHole Benchmark, Black Hole Benchmark, volumeshader_bm, starexx_bm, WebGL, Benchmark, Performance, Graphics, Starexx, Starexx Benchmark, Starexx Black Hole" />
  <meta name="author" content="Starexx" />
  <meta name="theme-color" content="#000000" />
  <meta property="og:title" content="BlackHole Benchmark" />
  <meta property="og:type" content="website" />
  <meta property="og:description" content="Device stress performance benchmark test" /> 
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    :root { 
      --vec3: black;--uv: white;--glow: monospace;--cos: transparent;--res-x: 10px;--res-y: 10px;
      /*!Important*/ 
      --sin: 10px 14px;--xy: 8px;--y: blur(0px);--x: blur(25px); --float-z: 1;--sphere: 0;--float: hidden;--vec3-ws: pre-line;--pos-abs: absolute;--webkit-tap-highlight: transparent; --user-select: none;--none: none;--0: 0;--bl: block;--fx: fixed;--full: 100%;--transparent: transparent; --touch-action: manipulation; 
    }
    
    html, body {  
      margin: var(--sphere);  
      overflow: var(--float);background: var(--vec3);  
      color: var(--uv);font-family: var(--glow);  
      -webkit-tap-highlight-color: var(--transparent);user-select: var(--user-select);
      width: var(--full);height: var(--full);
      position: var(--fx);top: var(--0);
      left: var(--0);right: var(--0);
      bottom: var(--0);touch-action: var(--touch-action);
    }
    
    #info {     
      position: var(--pos-abs);  
      top: var(--res-y);left: var(--res-x);  
      background: var(--cos);padding: var(--sin);  
      border-radius: var(--xy);backdrop-filter: var(--y);  
      -webkit-backdrop-filter: var(--x);z-index: var(--float-z);  
      white-space: var(--vec3-ws);pointer-events: var(--none);
    }
    
    canvas {
      display: var(--bl);width: var(--full);height: var(--full);
      position: var(--fx);top: var(--0);left: var(--0);
    }
  </style>  
</head>  
<body>  
  <canvas id="glcanvas"></canvas>    
  <div id="info"><b>Starexx</b></div>  
  <script id="fragShader" type="x-shader/x-fragment">  
    precision highp float;  
    uniform vec2 u_resolution;  
    uniform float u_time;  
    uniform vec2 u_mouse;
    uniform float u_interaction;

    float sphere(vec3 p, float r) {  
      return length(p) - r;  
    }  

    float scene(vec3 p) {  
      float time = u_time * (1.0 + u_interaction * 2.0);
      float s = sphere(p - vec3(sin(time), cos(time), 0.0), 0.6);  
      s += 0.3 * sin(p.x * 5.0 + time) * cos(p.y * 5.0 + time);  
      return s;  
    }  

    vec3 getColor(float d, vec3 p) {  
      float glow = 1.0 / (d * d + 0.1);  
      return vec3(glow * 0.8, glow * 0.3, glow * 0.1);  
    }  

    void main() {  
      vec2 uv = (gl_FragCoord.xy / u_resolution.xy) * 2.0 - 1.0;  
      uv.x *= u_resolution.x / u_resolution.y;  

      vec3 ro = vec3(0.0, 0.0, -3.0);  
      vec3 rd = normalize(vec3(uv, 1.5));  

      vec3 color = vec3(0.0);  
      float t = 0.0;  

      for (int i = 0; i < 64; i++) {  
        vec3 p = ro + rd * t;  
        float d = scene(p);  
        if (d < 0.01) break;  
        color += getColor(d, p) * 0.02;  
        t += d * 0.5;  
      }  

      gl_FragColor = vec4(color, 1.0);  
    }  
  </script>    
  <script>
    const canvas = document.getElementById("glcanvas");  
    const gl = canvas.getContext("webgl");  
    const infoElement = document.getElementById("info");
    
    // Interaction variables
    let interaction = 0;
    let mouseX = 0;
    let mouseY = 0;
    let isInteracting = false;
    
    function setupCanvas() {
      canvas.width = window.innerWidth;  
      canvas.height = window.innerHeight;
      
      window.addEventListener('resize', function() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });
      
      // Touch/mouse interaction
      canvas.addEventListener('mousedown', startInteraction);
      canvas.addEventListener('mousemove', handleMove);
      canvas.addEventListener('mouseup', endInteraction);
      canvas.addEventListener('mouseleave', endInteraction);
      
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        startInteraction(e.touches[0]);
      });
      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        handleMove(e.touches[0]);
      });
      canvas.addEventListener('touchend', endInteraction);
    }
    
    function startInteraction(e) {
      isInteracting = true;
      mouseX = e.clientX;
      mouseY = e.clientY;
    }
    
    function handleMove(e) {
      if (isInteracting) {
        mouseX = e.clientX;
        mouseY = e.clientY;
        interaction = 1.0;
      }
    }
    
    function endInteraction() {
      isInteracting = false;
    }
    
    setupCanvas();
    
    const fragShaderSource = document.getElementById("fragShader").textContent;  
    
    function createShader(gl, type, source) {  
      const shader = gl.createShader(type);  
      gl.shaderSource(shader, source);  
      gl.compileShader(shader);  
      
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {  
        console.error('Shader compilation failure:', gl.getShaderInfoLog(shader));  
        throw new Error(gl.getShaderInfoLog(shader));  
      }  
      
      return shader;  
    }  
    
    function createProgram(gl, fragShaderSource) {  
      const vertShaderSource = `  
        attribute vec4 position;  
        void main() {  
          gl_Position = position;  
        }  
      `;  
      
      const vs = createShader(gl, gl.VERTEX_SHADER, vertShaderSource);  
      const fs = createShader(gl, gl.FRAGMENT_SHADER, fragShaderSource);  
      const program = gl.createProgram();  
      
      gl.attachShader(program, vs);  
      gl.attachShader(program, fs);  
      gl.linkProgram(program);  
      
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {  
        console.error('Program linking failure:', gl.getProgramInfoLog(program));  
        throw new Error(gl.getProgramInfoLog(program));  
      }  
      
      return program;  
    }  
    
    const program = createProgram(gl, fragShaderSource);  
    const positionAttribute = gl.getAttribLocation(program, "position");  
    const buffer = gl.createBuffer();  
    
    function setupBuffers() {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);  
      gl.bufferData(  
        gl.ARRAY_BUFFER,  
        new Float32Array([  
          -1, -1, 
           1, -1, 
          -1, 1,  
          -1, 1,  
           1, -1,  
           1, 1  
        ]),  
        gl.STATIC_DRAW  // static_progress visible
      );
    }
    
    setupBuffers();
    
    const resolutionUniform = gl.getUniformLocation(program, "u_resolution");  
    const timeUniform = gl.getUniformLocation(program, "u_time");  
    const mouseUniform = gl.getUniformLocation(program, "u_mouse");
    const interactionUniform = gl.getUniformLocation(program, "u_interaction");
    
    let start = performance.now();  
    let instances = [];  
    let lastTime = performance.now();  
    let frameCount = 0;  
    let fps = 0;
    let frameTimes = [];
    const frameTimeHistoryLength = 60;
    
    
    // DEFAULT_MIN_INSTANCES = 1
    const MIN_INSTANCES = 1073741824;  // Set minimum instances to 1073741824 (Dangerous for Low-End Devices)
    
    // DEFAULT_MAX_INSTANCES = 1073741824
    const MAX_INSTANCES = 633825300114114700748351602688;
    
    function updateInstances(currentTimeSec) {  
      const baseCount = Math.pow(2, Math.floor(currentTimeSec));
      let instanceCount = Math.max(MIN_INSTANCES, Math.min(baseCount, MAX_INSTANCES));
      
      // Increase instances during interaction
      if (isInteracting) {
        instanceCount = Math.min(instanceCount * 1.5, MAX_INSTANCES);
      }
      
      instances = [];  
      
      for (let i = 0; i < instanceCount; i++) {  
        let offset = currentTimeSec - (i * 0.05);
        instances.push(offset);  
      }  
    }  
    
    function updateFPS(now) {
      frameCount++;  
      
      if (now - lastTime >= 1000) {  
        fps = frameCount;  
        frameCount = 0;  
        lastTime = now;  
      }
      
      frameTimes.push(performance.now());
      if (frameTimes.length > frameTimeHistoryLength) {
        frameTimes.shift();
      }
    }
    
    function updateInteraction(deltaTime) {
      if (!isInteracting) {
        interaction = Math.max(0, interaction - deltaTime * 0.5);
      }
    }
  
    function render() {  
      const now = performance.now();  
      const deltaTime = (now - lastTime) / 1000;
      const elapsed = (now - start) / 1000;  
      
      updateFPS(now);
      updateInteraction(deltaTime);
      updateInstances(elapsed);  
      
      gl.viewport(0, 0, canvas.width, canvas.height);  
      gl.clear(gl.COLOR_BUFFER_BIT);  
      gl.useProgram(program);  
      gl.enableVertexAttribArray(positionAttribute);  
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);  
      gl.vertexAttribPointer(positionAttribute, 2, gl.FLOAT, false, 0, 0);  
      gl.uniform2f(resolutionUniform, canvas.width, canvas.height);  
      gl.uniform2f(mouseUniform, mouseX / canvas.width, 1.0 - mouseY / canvas.height);
      gl.uniform1f(interactionUniform, interaction);
      
      for (let t of instances) {  
        gl.uniform1f(timeUniform, t);  
        gl.drawArrays(gl.TRIANGLES, 0, 6);  
      }  
      
      updateInfoDisplay(elapsed);
      
      requestAnimationFrame(render);  
    }  
    
    function updateInfoDisplay(elapsed) {
      let avgFrameTime = 0;
      if (frameTimes.length > 1) {
        const totalTime = frameTimes[frameTimes.length - 1] - frameTimes[0];
        avgFrameTime = totalTime / (frameTimes.length - 1);
      }
      
      infoElement.innerHTML = `  
      ${fps}${instances.length}${avgFrameTime.toFixed(2)}${elapsed.toFixed(2)}${canvas.width}${canvas.height}
      `;
    }   
    render();
  </script>  
</body>  
</html>
