<!doctype html>
<html lang="en"><head>
 <title>BlackHole Protocol</title>
     <meta http-equiv="X-UA-Compatible" content="IE=edge" />
     <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
     <meta name="description" content="An intense visual experience. Use with caution." />
     <meta name="keywords" content="blackhole test, BlackHole Benchmark, WebGL, Starexx" />
 <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

    :root {
        --bg-color: #000;
        --text-color: #00ff41;
        --glow-font: 'Share Tech Mono', monospace;
    }

    html, body {
        margin: 0;
        overflow: hidden;
        background: var(--bg-color);
        color: var(--text-color);
        font-family: var(--glow-font);
        -webkit-tap-highlight-color: transparent;
        width: 100%;
        height: 100%;
        position: fixed;
    }

    #info {
        position: absolute;
        top: 10px; left: 10px;
        background: transparent;
        pointer-events: none;
        z-index: 1;
        display: none; /* Initially hidden */
    }

    canvas {
        display: none; /* Initially hidden */
        width: 100%;
        height: 100%;
        position: fixed;
    }

    /* --- New Intro Screen --- */
    #intro-container {
        position: fixed; top: 0; left: 0;
        width: 100%; height: 100%;
        background: var(--bg-color);
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        z-index: 100;
        padding: 20px;
        box-sizing: border-box;
    }

    #animated-text {
        font-size: clamp(1em, 4vw, 1.8em);
        color: var(--text-color);
        text-shadow: 0 0 8px var(--text-color);
        text-align: center;
    }
    
    /* Blinking cursor effect */
    #animated-text .cursor {
        display: inline-block;
        background-color: var(--text-color);
        margin-left: 2px;
        width: 10px;
        animation: blink 1s infinite;
        box-shadow: 0 0 8px var(--text-color);
    }

    @keyframes blink { 50% { opacity: 0; } }

    #command-terminal {
        width: 90%;
        max-width: 800px;
        height: 400px;
        border: 1px solid var(--text-color);
        box-shadow: 0 0 10px var(--text-color);
        overflow: hidden;
        display: none; /* Hidden by default */
        padding: 10px;
        white-space: pre-wrap;
        word-wrap: break-word;
        font-size: clamp(0.8em, 2vw, 1em);
    }
    
    #loader-container-horizontal {
        width: 80%;
        max-width: 600px;
        height: 30px;
        border: 2px solid var(--text-color);
        box-shadow: 0 0 10px var(--text-color);
        display: none; /* Hidden by default */
        padding: 3px;
        box-sizing: border-box;
    }
    
    #loading-bar-fill-horizontal {
        width: 0%;
        height: 100%;
        background: var(--text-color);
        box-shadow: 0 0 15px var(--text-color);
    }
 </style>
     <meta property="og:description" content="Device stress performance test" />
     <meta property="og:title" content="BlackHole" /><meta name="author" content="Starexx" />
     <meta property="og:type" content="website" /><meta name="theme-color" content="#000000" />
  </head>
<body>

  <div id="intro-container">
    <p id="animated-text"><span class="cursor">&nbsp;</span></p>
    <pre id="command-terminal"></pre>
    <div id="loader-container-horizontal">
        <div id="loading-bar-fill-horizontal"></div>
    </div>
  </div>

  <canvas id="glcanvas"></canvas>
  <div id="info"></div>

  <script id="fragShader" type="x-shader/x-fragment">
    precision highp float;
    uniform vec2 u_resolution;
    uniform float u_time;
    uniform vec2 u_mouse;
    uniform float u_interaction;
    float sphere(vec3 p, float r) { return length(p) - r; }
    float scene(vec3 p) {
      float time = u_time * (1.0 + u_interaction * 2.0);
      float s = sphere(p - vec3(sin(time), cos(time), 0.0), 0.6);
      s += 0.3 * sin(p.x * 5.0 + time) * cos(p.y * 5.0 + time);
      return s;
    }
    vec3 getColor(float d, vec3 p) {
      float glow = 1.0 / (d * d + 0.1);
      return vec3(glow * 0.8, glow * 0.3, glow * 0.1);
    }
    void main() {
      vec2 uv = (gl_FragCoord.xy / u_resolution.xy) * 2.0 - 1.0;
      uv.x *= u_resolution.x / u_resolution.y;
      vec3 ro = vec3(0.0, 0.0, -3.0);
      vec3 rd = normalize(vec3(uv, 1.5));
      vec3 color = vec3(0.0);
      float t = 0.0;
      for (int i = 0; i < 64; i++) {
        vec3 p = ro + rd * t;
        float d = scene(p);
        if (d < 0.01) break;
        color += getColor(d, p) * 0.02;
        t += d * 0.5;
      }
      gl_FragColor = vec4(color, 1.0);
    }
  </script>
  <script>
    // --- Helper function for delays ---
    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    // --- New Intro Animation Logic ---
    const animatedText = document.getElementById('animated-text');
    const commandTerminal = document.getElementById('command-terminal');
    const loaderContainer = document.getElementById('loader-container-horizontal');
    const loaderFill = document.getElementById('loading-bar-fill-horizontal');
    const introContainer = document.getElementById('intro-container');

    const mainText = "Virus Injecting Into Your Device By TSun A Organization By ‡ºØùôé‡∏Ñ‡´ØùôÄùòø‚úòü´Ä";

    async function typeLine(element, text, speed) {
        element.innerHTML = '';
        for (let i = 0; i < text.length; i++) {
            element.innerHTML = text.substring(0, i + 1) + '<span class="cursor">&nbsp;</span>';
            await sleep(speed);
        }
    }

    async function deleteLine(element, speed) {
        const text = element.innerText;
        for (let i = text.length; i > 0; i--) {
            element.innerHTML = text.substring(0, i - 1) + '<span class="cursor">&nbsp;</span>';
            await sleep(speed);
        }
    }

    async function runCommands() {
        animatedText.style.display = 'none';
        commandTerminal.style.display = 'block';
        const commands = [
            '> Establishing connection to host... [OK]',
            '> Authenticating with root privileges...',
            '> Bypassing firewall... [ACCESS GRANTED]',
            '> Searching for system vulnerabilities... 3 found.',
            '> Exploiting kernel vulnerability CVE-2025-0901...',
            '> Injecting payload: `BlackHole.exe`',
            '> Payload size: 64.0 KB',
            '> Executing payload... SUCCESS.',
            '> Disabling system defenses...',
            '> Preparing for core overload sequence...'
        ];
        for (const cmd of commands) {
            commandTerminal.innerHTML += cmd + '\n';
            commandTerminal.scrollTop = commandTerminal.scrollHeight;
            await sleep(500); // 5 seconds total (500ms * 10 lines)
        }
    }

    async function startLoadingBar() {
        commandTerminal.style.display = 'none';
        loaderContainer.style.display = 'block';
        loaderFill.style.transition = 'width 5s linear'; // 5 second animation
        loaderFill.style.width = '100%';
        await sleep(5000);
    }

    async function startIntroSequence() {
        await typeLine(animatedText, mainText, 5000 / mainText.length); // Type over 5s
        await sleep(5000); // Wait for 5s
        await deleteLine(animatedText, 3000 / mainText.length); // Delete over 3s
        await runCommands(); // Run for 5s
        await startLoadingBar(); // Load for 5s
        introContainer.style.display = 'none';
        startBlackHole();
    }

    // --- Original BlackHole Logic (Now in "Attack Mode") ---
    function startBlackHole() {
        const glCanvas = document.getElementById("glcanvas");
        const infoDiv = document.getElementById("info");
        glCanvas.style.display = 'block';
        infoDiv.style.display = 'block';
        
        const gl = glCanvas.getContext("webgl");
        let audioContext; let oscillator; let gainNode;
        let interaction = 0; let mouseX = 0; let mouseY = 0; let isInteracting = false;

        function setupCanvas() {
            glCanvas.width = window.innerWidth; glCanvas.height = window.innerHeight;
            window.addEventListener('resize', () => { glCanvas.width = window.innerWidth; glCanvas.height = window.innerHeight; });
            glCanvas.addEventListener('mousedown', e => { isInteracting = true; mouseX = e.clientX; mouseY = e.clientY; });
            glCanvas.addEventListener('mousemove', e => { if (isInteracting) { mouseX = e.clientX; mouseY = e.clientY; interaction = 1.0; } });
            glCanvas.addEventListener('mouseup', () => { isInteracting = false; });
            glCanvas.addEventListener('mouseleave', () => { isInteracting = false; });
            glCanvas.addEventListener('touchstart', e => { e.preventDefault(); isInteracting = true; mouseX = e.touches[0].clientX; mouseY = e.touches[0].clientY; });
            glCanvas.addEventListener('touchmove', e => { e.preventDefault(); if (isInteracting) { mouseX = e.touches[0].clientX; mouseY = e.touches[0].clientY; interaction = 1.0; } });
            glCanvas.addEventListener('touchend', () => { isInteracting = false; });
            document.addEventListener('click', initAudioContext, { once: true });
            document.addEventListener('touchstart', initAudioContext, { once: true });
        }
        function initAudioContext() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            gainNode = audioContext.createGain(); gainNode.gain.value = 0;
            gainNode.connect(audioContext.destination);
        }
        function playBeep(fps) { /* Beep logic remains the same */ }
        setupCanvas();
        const fragShaderSource = document.getElementById("fragShader").textContent;
        function createShader(gl, type, source) {
            const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error('Shader compilation error:', gl.getShaderInfoLog(shader)); throw new Error(gl.getShaderInfoLog(shader)); }
            return shader;
        }
        function createProgram(gl, fragShaderSource) {
            const vertShaderSource = `attribute vec4 position; void main() { gl_Position = position; }`;
            const vs = createShader(gl, gl.VERTEX_SHADER, vertShaderSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fragShaderSource);
            const program = gl.createProgram(); gl.attachShader(program, vs); gl.attachShader(program, fs); gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { console.error('Program linking error:', gl.getProgramInfoLog(program)); throw new Error(gl.getProgramInfoLog(program)); }
            return program;
        }
        const program = createProgram(gl, fragShaderSource);
        const positionAttribute = gl.getAttribLocation(program, "position");
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
        const resolutionUniform = gl.getUniformLocation(program, "u_resolution");
        const timeUniform = gl.getUniformLocation(program, "u_time");
        const mouseUniform = gl.getUniformLocation(program, "u_mouse");
        const interactionUniform = gl.getUniformLocation(program, "u_interaction");
        let start = performance.now(), instances = [], lastTime = performance.now(), frameCount = 0, fps = 0, frameTimes = [];
        
        // --- REVERTED TO ORIGINAL "ATTACK" LOGIC ---
        const MIN_INSTANCES = 41824;
        function updateInstances(currentTimeSec) {
          const instanceCount = MIN_INSTANCES * Math.pow(2, currentTimeSec * 0.2);
          instances = [];
          for (let i = 0; i < instanceCount; i++) {
            instances.push(currentTimeSec - (i * 0.05));
          }
        }
        // --- END OF REVERT ---

        function updateFPS(now) { /* FPS logic remains the same */ }
        function updateInteraction(deltaTime) { if (!isInteracting) { interaction = Math.max(0, interaction - deltaTime * 0.5); } }
        
        function render() {
            const now = performance.now(); const elapsed = (now - start) / 1000;
            updateInstances(elapsed);
            gl.viewport(0, 0, glCanvas.width, glCanvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT); gl.useProgram(program);
            gl.enableVertexAttribArray(positionAttribute);
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(positionAttribute, 2, gl.FLOAT, false, 0, 0);
            gl.uniform2f(resolutionUniform, glCanvas.width, glCanvas.height);
            gl.uniform2f(mouseUniform, mouseX / glCanvas.width, 1.0 - mouseY / glCanvas.height);
            gl.uniform1f(interactionUniform, interaction);
            for (let t of instances) { gl.uniform1f(timeUniform, t); gl.drawArrays(gl.TRIANGLES, 0, 6); }
            requestAnimationFrame(render);
        }
        render();
    }
    
    // Start the whole sequence
    document.addEventListener('DOMContentLoaded', startIntroSequence);

</script>
</body>
</html>
